dfRW <- data.frame(R=R, W=W)
plot(dfRW$W,dfRW$R)
# set.seed(4)
Gamma <- rbind(c(0,0.9), c(0.9,0))
n <- 5000
x <- log(rmpareto(n, "HR", d =2, par = Gamma))
# x <- x[x[,1]>0&x[,2]>0,]
R <- apply(x, 1, function(x) sum(abs(x)))
W <- x[,1]/R
dfRW <- data.frame(R=R, W=W)
plot(dfRW$W,dfRW$R)
hist(dfRW$R[dfRW$R>4&dfRW$W>0,])
dfRW$R>4&dfRW$W>0
dfRW$R
hist(dfRW$R[dfRW$R>4&dfRW$W>0])
hist(((dfRW$R[dfRW$R>4&dfRW$W>0])-4)*4)
plot(dfRW$W,dfRW$R)
plot(dfRW.data$W,dfRW.data$excess)
rm(list=ls())
library(mvtnorm)
library(rmutil)
library(evgam)
library(tidyverse)
library(INLA)
library(inlabru)
library(rgl)
library(pracma)
library(graphicalExtremes)
## to install inla follow instructions in https://www.r-inla.org/download-install
##
## sample bivariate normal copula in exponential margins
##
# set.seed(4)
Gamma <- rbind(c(0,0.9), c(0.9,0))
n <- 5000
x <- log(rmpareto(n, "HR", d =2, par = Gamma))
# x <- x[x[,1]>0&x[,2]>0,]
R <- apply(x, 1, function(x) sum(abs(x)))
W <- x[,1]/R
dfRW <- data.frame(R=R, W=W)
plot(dfRW$W,dfRW$R)
p <- c(1:dim(x)[1])/(dim(x)[1]+1)
plot(qexp(p),sort(x[,1]))
abline(a=0,b=1)
hist(((dfRW$R[dfRW$R>4&dfRW$W>0])-4)*4)
# plot(x/log(n))
#
# par(mfrow=c(1,1))
# x.0 <- seq(0,10,by=0.01)
# y1 <- x.0 + 2*Gamma[1,2]+2*(2*Gamma[1,2]*x.0)^(.5)
# y2 <- x.0 + 2*Gamma[1,2]-2*(2*Gamma[1,2]*x.0)^(.5)
# lines(x.0,y1,col="red")
# lines(x.0,y2,col="red")
## ----------------------------------------------------------------------------
## Estimate threshold with quantile regression and cyclic b splines using evgam
## ----------------------------------------------------------------------------
## bivariate models
mod   <- evgam(list(R ~ s(W, bs='cc'), ~s(W, bs='cc')), family="ald", data=dfRW, ald.args=list(tau=0.7))
mod$threshold <- predict(mod)$location
mod$excess <- mod$R
## par(mfrow=c(1,2))
## plot(W,R)
## lines(W[order(W)], mod$threshold[order(W)], col=2, lwd=2)
dfRW$excess   <- dfRW$R - mod$threshold
dfRW$excess.scaled   <- (dfRW$R - mod$threshold)*mod$threshold
dfRW.data     <- dfRW %>% dplyr::filter(excess.scaled > 0)
dfRW.data$idx <- 1:nrow(dfRW.data)
plot(dfRW.data$W,dfRW.data$excess.scaled)
plot(dfRW.data$W,dfRW.data$excess)
plot(dfRW.data$W,dfRW.data$excess)
gauge <- function(W,gamma){
(2*W-1)^2/gamma
}
W <- seq(0,1,by=0.01)
gauge <- function(W,gamma){
(2*W-1)^2/gamma
}
plot(W,gauge(W,0.3))
exp(0.01)
exp(3)
plot(W,gauge(W,0.3))
gauge <- function(W,gamma){
(W-(1-W))^2/gamma
}
W <- seq(0,1,by=0.01)
plot(W,gauge(W,0.3))
gauge <- function(W,gamma){
(2*W-1)^2/gamma
}
log.lik <- function(gamma,X,W){
g <- gauge()
sum()
}
W <- seq(0,1,by=0.01)
plot(W,gauge(W,0.3))
plot(W,1/gauge(W,0.3))
plot(W,1/gauge(W,0.2))
plot(W,1/gauge(W,0.1))
W <- seq(0,1,by=0.001)
plot(W,1/gauge(W,0.1))
plot(W,1/gauge(W,0.1),type="l")
W <- seq(0,1,by=0.001)
plot(W,1/gauge(W,0.5),type="l")
gauge <- function(W,gamma){
(2*W-1)^2/(2*gamma)
}
log.lik <- function(gamma,W,R,u){
lambda <- gauge(W,gamma)
y <- (R+u)^2
sum()
}
W <- seq(0,1,by=0.001)
plot(W,1/gauge(W,0.5),type="l")
plot(W,1/gauge(W,4),type="l")
plot(W,1/gauge(W,0.001),type="l")
plot(W,1/gauge(W,0.001)^(0.5),type="l")
plot(W,1/gauge(W,0.2)^(0.5),type="l")
lod.dens.weib.exc <- function(gamma,W,R,u){
lambda <- (2*W-1)^2/(2*gamma)
log(2)-2*log(lambda)+log(R)-(R^2-u)/lambda^2
}
dfRW.data[1,]
rm(list=ls())
library(mvtnorm)
library(rmutil)
library(evgam)
library(tidyverse)
library(INLA)
library(inlabru)
library(rgl)
library(pracma)
library(graphicalExtremes)
## to install inla follow instructions in https://www.r-inla.org/download-install
##
## sample bivariate normal copula in exponential margins
##
# set.seed(4)
Gamma <- rbind(c(0,0.9), c(0.9,0))
n <- 5000
x <- log(rmpareto(n, "HR", d =2, par = Gamma))
# x <- x[x[,1]>0&x[,2]>0,]
R <- apply(x, 1, function(x) sum(abs(x)))
W <- x[,1]/R
dfRW <- data.frame(R=R, W=W)
plot(dfRW$W,dfRW$R)
p <- c(1:dim(x)[1])/(dim(x)[1]+1)
plot(qexp(p),sort(x[,1]))
abline(a=0,b=1)
hist(((dfRW$R[dfRW$R>4&dfRW$W>0])-4)*4)
# plot(x/log(n))
#
# par(mfrow=c(1,1))
# x.0 <- seq(0,10,by=0.01)
# y1 <- x.0 + 2*Gamma[1,2]+2*(2*Gamma[1,2]*x.0)^(.5)
# y2 <- x.0 + 2*Gamma[1,2]-2*(2*Gamma[1,2]*x.0)^(.5)
# lines(x.0,y1,col="red")
# lines(x.0,y2,col="red")
## ----------------------------------------------------------------------------
## Estimate threshold with quantile regression and cyclic b splines using evgam
## ----------------------------------------------------------------------------
## bivariate models
mod   <- evgam(list(R ~ s(W, bs='cc'), ~s(W, bs='cc')), family="ald", data=dfRW, ald.args=list(tau=0.7))
mod$threshold <- predict(mod)$location
mod$excess <- mod$R
## par(mfrow=c(1,2))
## plot(W,R)
## lines(W[order(W)], mod$threshold[order(W)], col=2, lwd=2)
dfRW$excess   <- dfRW$R - mod$threshold
dfRW$excess.scaled   <- (dfRW$R - mod$threshold)*mod$threshold
dfRW$u <- mod$threshold
dfRW.data     <- dfRW %>% dplyr::filter(excess.scaled > 0)
dfRW.data$idx <- 1:nrow(dfRW.data)
plot(dfRW.data$W,dfRW.data$excess.scaled)
plot(dfRW.data$W,dfRW.data$excess)
gauge <- function(W,gamma){
(2*W-1)^2/(2*gamma)
}
lod.dens.weib.exc <- function(gamma,W,R,u){
lambda <- (2*W-1)^2/(2*gamma)
log(2)-2*log(lambda)+log(R)-(R^2-u)/lambda^2
}
lod.dens.weib.exc(0.4,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
lod.dens.weib.exc(0.9,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
lod.dens.weib.exc(10,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
lod.dens.weib.exc(0.1,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
log.lik <- function(gamma,W,R,u){
sum(lod.dens.weib.exc(gamma,W,R,u))
}
log.lik(0.2,dfRW.data$W,dfRW.data$R,dfRW.data$u)
log.lik(0.5,dfRW.data$W,dfRW.data$R,dfRW.data$u)
log.lik(0.9,dfRW.data$W,dfRW.data$R,dfRW.data$u)
log.lik(0.1,dfRW.data$W,dfRW.data$R,dfRW.data$u)
log.lik(02,dfRW.data$W,dfRW.data$R,dfRW.data$u)
neg.log.lik <- function(gamma,W,R,u){
-sum(lod.dens.weib.exc(gamma,W,R,u))
}
neg.log.lik(1,dfRW.data$W,dfRW.data$R,dfRW.data$u)
neg.log.lik(4,dfRW.data$W,dfRW.data$R,dfRW.data$u)
optim(c(0),neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
optimize(c(0),neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
optimize(neg.log.lik,lower=0,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
optimize(neg.log.lik,interval=c(0,.Machine$double.xmax),W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
optim(c(0),neg.log.lik,method="Brent",W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
optim(c(0),neg.log.lik,method="Brent",lower=0,upper=.Machine$double.xmax,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
gammas <- seq(0,3,by=0.02)
lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
v
plot(v)
gammas <- seq(0,10,by=0.02)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(v)
lod.dens.weib.exc <- function(gamma,W,R,u){
lambda <- (2*W-1)^2/(2*gamma)
log(2)-2*log(lambda)+log(R)-(R^2-u^2)/lambda^2
}
lod.dens.weib.exc(0.1,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
neg.log.lik <- function(gamma,W,R,u){
-sum(lod.dens.weib.exc(gamma,W,R,u))
}
gammas <- seq(0,10,by=0.02)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(v)
gammas <- seq(0,100,by=0.02)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(v)
gammas <- seq(0,2,by=0.02)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(v)
plot(gammas,v)
# set.seed(4)
Gamma <- rbind(c(0,0.9), c(0.9,0))
n <- 5000
x <- log(rmpareto(n, "HR", d =2, par = Gamma))
# x <- x[x[,1]>0&x[,2]>0,]
R <- apply(x, 1, function(x) sum(abs(x)))
W <- x[,1]/R
dfRW <- data.frame(R=R, W=W)
plot(dfRW$W,dfRW$R)
p <- c(1:dim(x)[1])/(dim(x)[1]+1)
plot(qexp(p),sort(x[,1]))
plot(dfRW$W,dfRW$R)
dfRW <- dfRW[dfRW$W>0,]
plot(dfRW$W,dfRW$R)
## ----------------------------------------------------------------------------
## Estimate threshold with quantile regression and cyclic b splines using evgam
## ----------------------------------------------------------------------------
## bivariate models
mod   <- evgam(list(R ~ s(W, bs='cc'), ~s(W, bs='cc')), family="ald", data=dfRW, ald.args=list(tau=0.7))
mod$threshold <- predict(mod)$location
mod$excess <- mod$R
## par(mfrow=c(1,2))
## plot(W,R)
## lines(W[order(W)], mod$threshold[order(W)], col=2, lwd=2)
dfRW$excess   <- dfRW$R - mod$threshold
dfRW$excess.scaled   <- (dfRW$R - mod$threshold)*mod$threshold
dfRW$u <- mod$threshold
dfRW.data     <- dfRW %>% dplyr::filter(excess.scaled > 0)
dfRW.data$idx <- 1:nrow(dfRW.data)
plot(dfRW.data$W,dfRW.data$excess.scaled)
plot(dfRW.data$W,dfRW.data$excess)
gauge <- function(W,gamma){
(2*W-1)^2/(2*gamma)
}
lod.dens.weib.exc <- function(gamma,W,R,u){
lambda <- (2*W-1)^2/(2*gamma)
log(2)-2*log(lambda)+log(R)-(R^2-u^2)/lambda^2
}
lod.dens.weib.exc(0.1,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
neg.log.lik <- function(gamma,W,R,u){
-sum(lod.dens.weib.exc(gamma,W,R,u))
}
gammas <- seq(0,2,by=0.02)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(gammas,v)
gammas <- seq(0,0.1,by=0.001)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(gammas,v)
gammas <- seq(0,0.01,by=0.0001)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(gammas,v)
gauge <- function(W,gamma){
(2*W-1)^2/(2*gamma)
}
lod.dens.weib.exc <- function(gamma,W,R,u){
lambda <- (2*W-1)^2/(2*gamma)
log(2)-2*log(lambda)+log(R)-(R^2-u^2)/lambda^2
}
W <- seq(0,1,by=0.01)
plot(W,gauge(W,0.01))
plot(W,1/(2*gauge(W,0.01)))
plot(W,1/(2*gauge(W,0.001)))
plot(W,1/(2*gauge(W,0.0001)))
W <- seq(0,1,by=0.01)
plot(W,1/(2*gauge(W,0.0001)))
W <- seq(0,1,by=0.01)
plot(W,1/(2*gauge(W,0.00001)))
plot(W,1/(gauge(W,0.00001)^(.5)))
plot(W,1/(gauge(W,0.001)^(.5)))
plot(W,1/(gauge(W,0.1)^(.5)))
lod.dens.weib.exc <- function(gamma,W,R,u){
inv.lambda <- (2*gamma)/(2*W-1)^2
log(2)-log(lambda)+log(R)-(R^2-u^2)/lambda
}
W <- seq(0,1,by=0.01)
plot(W,1/(gauge(W,0.1)^(.5)))
lod.dens.weib.exc(0.1,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
lod.dens.weib.exc <- function(gamma,W,R,u){
inv.lambda <- (2*gamma)/(2*W-1)^2
log(2)-log(inv.lambda)+log(R)-(R^2-u^2)/inv.lambda
}
W <- seq(0,1,by=0.01)
plot(W,1/(gauge(W,0.1)^(.5)))
lod.dens.weib.exc(0.1,dfRW.data[1,]$W,dfRW.data[1,]$R,dfRW.data[1,]$u)
neg.log.lik <- function(gamma,W,R,u){
-sum(lod.dens.weib.exc(gamma,W,R,u))
}
gammas <- seq(0,0.01,by=0.0001)
l <- lapply(gammas,neg.log.lik,W=dfRW.data$W,R=dfRW.data$R,u=dfRW.data$u)
v <- unlist(l)
plot(gammas,v)
# Set current wd to KAUST_Course
# setwd(".../KAUST_Course/")
SP500 <- read.table("Data/SP500_daily.csv", header=TRUE, sep=",")
getwd()
setwd("C:/Users/lambe/Documents/Edinburgh/PhD/KAUST/KAUST_Course/")
getwd()
# Set current wd to KAUST_Course
# setwd(".../KAUST_Course/")
SP500 <- read.table("Data/SP500_daily.csv", header=TRUE, sep=",")
par(mfrow=c(1,1),mgp=c(3,0.8,0),mar=c(5,5,0.5,0.5))
plot(as.Date(SP500$Date),SP500$Close,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
rets <- c()
for(i in 1:(length(SP500$Close)-1)){
rets <- c(rets,(SP500$Close[i]-SP500$Close[i+1])/SP500$Close[i])
}
plot(as.Date(SP500$Date)[1:(length(SP500$Date)-1)],rets,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
# ---------------------------- Slide 42 -----------------------------
# Get the squared returns
rets.2 <- rets^2
plot(as.Date(SP500$Date)[1:(length(SP500$Date)-1)],rets.2,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
# ---------------------------- Slide 43 -----------------------------
us <- seq(0.0001,0.0016,by=0.00005)
# Compute the extremal index for a range of u's (us)
fexi <- function(u,returns,r) exi(returns,u=u,r=r)
thetas.sp500 <- unlist(lapply(us,fexi,returns = rets.2,r=10))
# ---------------------------- Slide 16 -----------------------------
library(evd)
library(ismev)
# Set current wd to KAUST_Course
# setwd(".../KAUST_Course/")
SP500 <- read.table("Data/SP500_daily.csv", header=TRUE, sep=",")
par(mfrow=c(1,1),mgp=c(3,0.8,0),mar=c(5,5,0.5,0.5))
plot(as.Date(SP500$Date),SP500$Close,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
rets <- c()
for(i in 1:(length(SP500$Close)-1)){
rets <- c(rets,(SP500$Close[i]-SP500$Close[i+1])/SP500$Close[i])
}
plot(as.Date(SP500$Date)[1:(length(SP500$Date)-1)],rets,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
# ---------------------------- Slide 42 -----------------------------
# Get the squared returns
rets.2 <- rets^2
plot(as.Date(SP500$Date)[1:(length(SP500$Date)-1)],rets.2,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
# ---------------------------- Slide 43 -----------------------------
us <- seq(0.0001,0.0016,by=0.00005)
# Compute the extremal index for a range of u's (us)
fexi <- function(u,returns,r) exi(returns,u=u,r=r)
thetas.sp500 <- unlist(lapply(us,fexi,returns = rets.2,r=10))
plot(us,thetas.sp500,ylim=c(0,1),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
abline(v=0.0004,lty="dotted")
# Display the mean of thetas above 0.0003
mean.theta <- mean(thetas.sp500[5:length(thetas.sp500)])
lines(cbind(c(0.0004,0.002),rep(mean.theta,2)),col="red")
# ---------------------------- Slide 44 -----------------------------
# Moving average length
h <- 20
# Store moving averages, moving sd, residuals
means <- c()
sds <- c()
res <- c()
for(i in (1+h/2):(length(rets)-h/2)){
m <- mean(rets[(i-h/2):(i+h/2)])
means <- c(means,m)
s <- sd(rets[(i-h/2):(i+h/2)])
sds <- c(sds,s)
res <- c(res,(rets[i]-m)/s)
}
# Compute standardised returns
res <- (rets[(h/2+1):(length(rets)-h/2)]-means)/sds
# Plot the squared standardised returns
subseq.dts <- as.Date(SP500$Date)[(1+h/2):(length(SP500$Date)-(1+h/2))]
plot(subseq.dts,res^2,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
# ---------------------------- Slide 45 -----------------------------
# Compute extremal indexes for m=1,2 and various u's (us)
thetas.res1 <- c()
thetas.res2 <- c()
thetas.res3 <- c()
us <- seq(0,6,by=0.01)
for(u in us){
thetas.res1 <- c(thetas.res1,exi(res^2,u=u,r=1))
thetas.res2 <- c(thetas.res2,exi(res^2,u=u,r=2))
thetas.res3 <- c(thetas.res3,exi(res^2,u=u,r=0))
}
# Plot extremal indexes computed for m=1,2 and various u's (us)
par(mfrow=c(1,2),mar=c(4.1,6.1,2,0.2))
plot(us,thetas.res1,ylim=c(0,1),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l",lwd=2)
lines(us,thetas.res2,col="blue",lwd=2)
lines(us,thetas.res3,col="red",lwd=2)
legend(4,0.4,legend=c("m=1","m=2"),col=c("black","blue"),
lty=c(1,1),lwd = c(3,3))
# ---------------------------- Slide 47 -----------------------------
# Obtain list of clusters defined for u=0.0003
u <- 0.0004
cs <- clusters(rets.2,u=u,r=10)
length(cs)
# Store the maxima from each cluster
maxima <- c()
# Store index of cluster maxima within all squred returns
ind.max <- c()
for(i in 1:length(cs)){
# Get maxima of cluster i
maxima <- c(maxima,max(cs[[i]]))
# Get index of all values in cluster i
ind.clust.i <- as.numeric(names(cs[[34]]))
# Select index corresponding to maxima within cluster i
ind <- ind.clust.i[which.max(cs[[i]])]
ind.max <- c(ind.max,ind)
}
# Get index of values exceeding u (i.e. those in clusters)
ind.c <- which(rets.2>u)
dts <- as.Date(SP500$Date)[1:(length(SP500$Date)-1)]
plot(dts,rets.2,ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,type="l")
points(dts[ind.c],rets.2[ind.c],col="blue",pch=20)
points(dts[ind.max],rets.2[ind.max],col="red",pch=20)
# ---------------------------- Slide 49 -----------------------------
library(ismev)
fit <- gpd.fit(maxima,threshold=u)
diag <- gpd.diag(fit)
sig.u <- fit$mle[1]
xi <- fit$mle[2]
n.exc.u <- length(rets.2[rets.2>u])
sig <- sig.u*n.exc.u^xi
mu <- u + (sig-sig.u)/xi
sig
mu
# ---------------------------- Slide 50 -----------------------------
ps <- c(1:length(cs))/(length(cs)+1)
# PP plot of GPD fit on maxima of clusters of squared standardised returns
par(mfrow=c(1,2),mgp=c(3,0.8,0),mar=c(5,5,2.5,0.5))
plot(ps,sort(pgpd(maxima,u,fit$mle[1],fit$mle[2])),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,cex.main=2,main="ZZZZZ")
abline(a=0,b=1)
# QQ plot of GPD fit on maxima of clusters of squared standardised returns
qs <- qgpd(ps,u,fit$mle[1],fit$mle[2])
plot(qs,sort(maxima),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,cex.main=2,main="WWWWW")
abline(a=0,b=1)
rets.2
acf(rets.2,lag.max=100)
length(rets.2)/34
# PP plot of GPD fit on maxima of clusters of squared standardised returns
par(mfrow=c(1,2),mgp=c(3,0.8,0),mar=c(5,5,2.5,0.5))
plot(ps,sort(pgpd(maxima,u,fit$mle[1],fit$mle[2])),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,cex.main=2,main="ZZZZZ")
abline(a=0,b=1)
# QQ plot of GPD fit on maxima of clusters of squared standardised returns
qs <- qgpd(ps,u,fit$mle[1],fit$mle[2])
plot(qs,sort(maxima),ylab="YYYYY",xlab="XXXXX",
cex.lab=2,cex.axis=1.5,cex.main=2,main="WWWWW")
abline(a=0,b=1)
P <-rbind(c(1/3,1/3,1/3),
c(0,2/3,1/3),
c(2/3,1/3,0))
P.0 <- rep(1/3,3)
P.3 <- P.0 %*% P %*% P
P <-rbind(c(1/3,1/3,1/3),
c(0,2/3,1/3),
c(2/3,1/3,0))
P.0 <- rep(1/3,3)
P.3 <- P.0 %*% P %*% P %*% P
P_0_to_23 <- sum(P.3[2:3])
P_0_to_23
P.3 <- P.0 %*% P %*% P
P_0_to_23 <- sum(P.3[2:3])
P_0_to_23
P %*% P %*% P
P.0 %*% P %*% P %*% P
P_0_to_23 <- sum(P.3[2:3])
P_0_to_23
P %*% P
sum(P.3[2:3])
P_0_to_23
P_0_to_23 <- sum(P.3[2:3])
